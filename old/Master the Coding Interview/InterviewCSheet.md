### Step By Step through a problem:

1. **면접관이 질문을 하면 상단에 요점을 적습니다** (즉, 정렬된 배열). 

   모든 세부 정보가 있는지 확인하십시오. 당신이 얼마나 **조직적**인지 보여주세요.

2. 꼭 **재확인**하세요 입력 항목은 무엇입니까? 출력은 무엇입니까?

3. **문제의 가장 중요한 가치**는 무엇입니까? 당신은 시간과 공간과 메모리여유가 있습니까? 주요 목표는 무엇입니까?

4. 성가시게 하지 말고 너무 많은 질문을 하세요.

5. **순진한/무차별적인 접근으로 시작**하십시오. 가장 먼저 떠오르는 것. 

   당신이 잘 생각하고 비판적으로 생각할 수 있음을 보여줍니다 

   (**당신은 이 코드를 작성할 필요가 없습니다. 단지 그것에 대해 이야기하십시오**)

6. 이 방법이 최선이 아닌 이유를 설명하십시오. (즉, O(n^2) 이상, 읽을 수 없음 등...)

7. **접근 방식을 살펴보고, 의견을 제시하고, 문제를 해결할 수 있는 부분을 확인**합니다. 

   반복, O(N^2)와 같은 병목 현상 또는 불필요한 작업이 있습니까? 면접관이 알려준 정보는 모두 활용하셨나요? 

   병목 현상은 Big O가 가장 큰 코드의 일부입니다. 그것에 집중하세요. 때때로 이것은 반복 작업에서도 발생합니다.

8. 코딩을 시작하기 전에 코드를 살펴보고 **수행할 단계를 기록**하십시오.

9. 처음부터 코드를 **모듈화**하십시오. 코드를 아름다운 작은 조각으로 나누고 필요한 경우 주석만 추가합니다.

10. 이제 실제로 코드 작성을 시작하십시오. 

    코딩에 필요한 것을 더 많이 준비하고 이해할수록 화이트보드가 더 좋아질 것임을 명심하십시오. 

    따라서 일이 어떻게 될지 확신이 서지 않고 화이트보드 인터뷰를 시작하지 마십시오. 그것이 재앙의 비법입니다. 

    명심하세요: 많은 인터뷰에서 제 시간에 완전히 대답할 수 없는 질문을 합니다. 따라서 생각해 보십시오. 

    내가 이 일을 할 수 있고 다른 코더보다 더 낫다는 것을 보여주기 위해 무엇을 보여줄 수 있습니까? 

    **Functions에서 작업 나누기** (메소드가 기억나지 않는다면, 그냥 함수를 만들고 적어도 거기에 있을 것입니다. 

    무언가를 작성하고 쉬운 부분부터 시작하십시오.

11. **오류 검사와 이 코드를 깨는 방법에 대해 생각**해 보십시오. 입력에 대해 가정하지 마십시오. 

    사람들이 당신의 코드를 깨려고 하고 있고 Darth Vader가 당신의 기능을 사용하고 있다고 가정합니다. 

    어떻게 보호할 것인가? 원하지 않는 잘못된 입력이 있는지 항상 확인하십시오. 여기에 트릭이 있습니다. 

    코드에 주석을 달고 수행하려는 검사... 

    함수를 작성한 다음 면접관에게 지금 테스트를 작성하여 함수를 실패하게 만들 것이라고 말합니다

    (그러나 실제로 다음을 작성할 필요는 없습니다. 테스트). 

12. i 및 j와 같이 나쁘거나 혼동되는 이름을 사용하지 마십시오. **잘 읽히는 코드를 작성**하십시오.

13. **코드 테스트**: 매개변수 없음, 0, 정의되지 않음, null, 대규모 배열, 비동기 코드 등을 확인합니다. 

    코드에 대해 가정할 수 있는지 면접관에게 물어보십시오. 답변이 오류를 반환하도록 할 수 있습니까? 

    솔루션에 구멍을 뚫습니다. 당신은 자신을 반복하고 있습니까?

14. 마지막으로 면접관에게 코드를 개선할 부분에 대해 이야기하십시오. 작동합니까? **다른 접근 방식이 있습니까?** 

    읽을 수 있습니까? Google에서 개선할 점은 무엇입니까? **성능을 어떻게 향상시킬 수 있습니까?** 

    가능하면: **면접관에게 이 문제에 대해 본 가장 흥미로운 해결책이 무엇인지 물어보십시오.**

15. 면접관이 해결 방법에 만족하면 일반적으로 면접이 여기서 끝납니다. 

    또한 면접관이 전체 입력이 메모리에 맞지 않거나 입력이 스트림으로 도착하는 경우 문제를 처리하는 방법과 같은 확장 질문을 하는 것이 일반적입니다. 

    이것은 규모에 대해 많은 관심을 갖고 있는 Google의 일반적인 후속 질문입니다. 대답은 일반적으로 **분할 정복 방식**입니다. 데이터의 분산 처리를 수행하고 디스크에서 메모리로 입력의 특정 청크만 읽고 출력을 디스크에 다시 쓰고 나중에 결합합니다.



**좋은 코드 체크리스트**

[✅]작동합니다 

[✅]자료 구조의 좋은 사용 

[✅]코드 재사용/반복하지 마세요 

[✅]모듈식 - 코드를 더 읽기 쉽고, 유지 관리하고, 테스트 가능하게 만듭니다. 

[✅]O(N^2)보다 작습니다. 중첩 루프는 비용이 많이 들기 때문에 가능하면 피하고 싶습니다. 두 개의 개별 루프가 2개의 중첩 루프보다 낫습니다. 

[✅]낮은 공간 복잡성 --> 재귀로 인해 스택 오버플로가 발생할 수 있습니다. 큰 배열을 복사하면 머신의 메모리를 초과할 수 있습니다. 

에이스 질문에 대한 휴리스틱: 

[✅]해시 맵은 일반적으로 시간 복잡도를 개선하는 답입니다 

[✅]정렬된 배열이라면 바이너리 트리를 사용하여 O(log N)를 달성하세요. 

분할 및 정복 - 데이터 세트를 더 작은 청크로 나눈 다음 데이터 하위 집합으로 프로세스를 반복합니다. 

이진 검색이 이에 대한 좋은 예입니다. 

[✅]입력을 정렬해 보세요 

[✅]해시 테이블 및 미리 계산된 정보(예: 정렬)